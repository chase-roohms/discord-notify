---
name: Discord Notifier
author: Chase Roohms
description: Send messages to Discord via webhook
branding:
  icon: 'bell'
  color: 'purple'

inputs:
  webhook_url:
    description: 'The Discord webhook URL to send the message to'
    required: true
  #### Parts of the normal message, that are not in an embed ####
  # All of these options are optional, but at least one of content, attachment-files,
  # or attachment-urls must be provided if you do not provide any embeds below.
  content:
    description: 'The message to send to Discord, used in the "content" field if embeds are enabled.'
    required: false
    default: ''
  username:
    description: 'The username to display as the message sender'
    required: false
    default: ''
  avatar_url:
    description: 'The URL of the avatar image to use for the message sender'
    required: false
    default: ''
  attachment-files:
    description: 'A newline-separated list of files to upload and attach to the message (mutually exclusive with attachment-urls)'
    required: false
    default: ''
  attachment-urls:
    description: 'A newline-separated list of URLs to attach to the message (mutually exclusive with attachment-files)'
    required: false
    default: ''
  
  #### Embed options ####
  # You can attach up to 10 embeds per message, each with their own options
  # meaning that for each of these you can specify a single value, or a json
  # array of values. If you specify a single value, it will be used for all embeds.
  # If you specify a json array, it should contain one entry per embed.
  # For example, to send 3 embeds with different titles, you would set
  # embed-titles to '["Title 1", "Title 2", "Title 3"]'
  # If you only wanted to set the title for the first embed, and leave the rest blank,
  # you would set embed-titles to '["Title 1", "", ""]'
  # If you wanted to send 2 embeds, both with the same title, you would set
  # embed-titles to 'Common Title'

  # Author fields
  embed-authors:
    description: 'The authors of the embeds to include in the message'
    required: false
    default: ''
  embed-author-urls:
    description: 'The author URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-author-icons:
    description: 'The author icon URLs of the embeds to include in the message'
    required: false
    default: ''
  
  # Main embed fields
  embed-titles:
    description: 'The titles of the embeds to include in the message'
    required: false
    default: ''
  embed-descriptions:
    description: 'The descriptions of the embeds to include in the message'
    required: false
    default: ''
  embed-urls:
    description: 'The URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-colors:
    description: 'The colors of the embeds to include in the message, as hex values (e.g., FF0000 for red)'
    required: false
    default: ''
  embed-image-urls:
    description: 'The main image URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-thumbnail-urls:
    description: 'The thumbnail image URLs of the embeds to include in the message'
    required: false
    default: ''
  
  # Fields
  embed-fields:
    # Expecting JSON arrays like: [{"name": "Field 1", "value": "Value 1", "inline": true}, {"name": "Field 2", "value": "Value 2", "inline": false}]
    description: 'The fields of the embeds to include in the message, as JSON arrays'
    required: false
    default: ''

  # Footer fields
  embed-footers:
    description: 'The footers of the embeds to include in the message'
    required: false
    default: ''
  embed-footer-icons:
    description: 'The footer icon URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-timestamps:
    description: 'The timestamps of the embeds to include in the message, as ISO 8601 strings. Or "now" for the current time.'
    required: false
    default: ''

outputs: 
  status_code:
    description: 'The HTTP status code of the Discord message request'
    value: ${{ steps.send_discord_message.outputs.status_code }}
  payload:
    description: 'The full payload sent to Discord'
    value: ${{ steps.build_payload.outputs.payload }}
  payload_file:
    description: 'The file path of the payload sent to Discord'
    value: ${{ steps.build_payload.outputs.payload_file }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        # Ensure script doesn't exit on command failures
        set +e
        
        # Color codes for output
        RED='\033[0;31m'
        YELLOW='\033[1;33m'
        NC='\033[0m' # No Color
        
        # Track validation errors
        ERRORS=()
        
        # Validate webhook_url (required)
        if [[ -z "${{ inputs.webhook_url }}" ]]; then
          ERRORS+=("webhook_url is required")
        elif [[ ! "${{ inputs.webhook_url }}" =~ ^https://discord(app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+$ ]]; then
          ERRORS+=("webhook_url must be a valid Discord webhook URL (format: https://discord.com/api/webhooks/{id}/{token})")
        fi
        
        # Validate avatar_url if provided
        if [[ -n "${{ inputs.avatar_url }}" ]] && [[ ! "${{ inputs.avatar_url }}" =~ ^https?:// ]]; then
          ERRORS+=("avatar_url must be a valid URL starting with http:// or https://")
        fi
        
        # Validate attachment-files and attachment-urls are mutually exclusive
        if [[ -n "${{ inputs.attachment-files }}" ]] && [[ -n "${{ inputs.attachment-urls }}" ]]; then
          ERRORS+=("attachment-files and attachment-urls are mutually exclusive - provide only one")
        fi
        
        # Validate attachment-urls format if provided
        if [[ -n "${{ inputs.attachment-urls }}" ]]; then
          while IFS= read -r url; do
            [[ -z "$url" ]] && continue
            if [[ ! "$url" =~ ^https?:// ]]; then
              ERRORS+=("attachment-urls contains invalid URL: $url (must start with http:// or https://)")
            fi
          done <<< "${{ inputs.attachment-urls }}"
        fi
        
        # Validate attachment-files exist if provided
        if [[ -n "${{ inputs.attachment-files }}" ]]; then
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ ! -f "$file" ]]; then
              ERRORS+=("attachment-files references non-existent file: $file")
            fi
          done <<< "${{ inputs.attachment-files }}"
        fi
        
        # Validate embed inputs
        embed_count=0
        declare -A array_lengths
        
        # Check each embed field and track array lengths
        check_embed_field() {
          local field_name="$1"
          local field_value="$2"
          
          if [[ -n "$field_value" ]]; then
            if [[ "$field_value" =~ ^\[.*\]$ ]]; then
              # It's a JSON array - validate and get its length
              if echo "$field_value" | jq empty 2>/dev/null; then
                # Special handling for embed-fields: check if it's an array of objects (single embed) 
                # vs array of arrays (multiple embeds)
                if [[ "$field_name" == "embed-fields" ]]; then
                  # Check if first element is an array or an object
                  local first_elem=$(echo "$field_value" | jq '.[0] | type' 2>/dev/null)
                  if [[ "$first_elem" == '"array"' ]]; then
                    # Array of arrays - multiple embeds
                    local length=$(echo "$field_value" | jq '. | length' 2>/dev/null)
                    if [[ -n "$length" ]] && [[ "$length" =~ ^[0-9]+$ ]]; then
                      array_lengths["$field_name"]=$length
                      [[ $length -gt $embed_count ]] && embed_count=$length
                    fi
                  else
                    # Array of objects - single embed value
                    [[ $embed_count -lt 1 ]] && embed_count=1
                  fi
                else
                  # Regular field - array means multiple embeds
                  local length=$(echo "$field_value" | jq '. | length' 2>/dev/null)
                  if [[ -n "$length" ]] && [[ "$length" =~ ^[0-9]+$ ]]; then
                    array_lengths["$field_name"]=$length
                    [[ $length -gt $embed_count ]] && embed_count=$length
                  fi
                fi
              fi
            else
              # It's a single value - this is fine, it will be used for all embeds
              [[ $embed_count -lt 1 ]] && embed_count=1
            fi
          fi
        }
        
        # Check all embed fields
        check_embed_field "embed-authors" ${{ toJSON(inputs.embed-authors) }}
        check_embed_field "embed-author-urls" ${{ toJSON(inputs.embed-author-urls) }}
        check_embed_field "embed-author-icons" ${{ toJSON(inputs.embed-author-icons) }}
        check_embed_field "embed-titles" ${{ toJSON(inputs.embed-titles) }}
        check_embed_field "embed-descriptions" ${{ toJSON(inputs.embed-descriptions) }}
        check_embed_field "embed-urls" ${{ toJSON(inputs.embed-urls) }}
        check_embed_field "embed-colors" ${{ toJSON(inputs.embed-colors) }}
        check_embed_field "embed-image-urls" ${{ toJSON(inputs.embed-image-urls) }}
        check_embed_field "embed-thumbnail-urls" ${{ toJSON(inputs.embed-thumbnail-urls) }}
        check_embed_field "embed-fields" ${{ toJSON(inputs.embed-fields) }}
        check_embed_field "embed-footers" ${{ toJSON(inputs.embed-footers) }}
        check_embed_field "embed-footer-icons" ${{ toJSON(inputs.embed-footer-icons) }}
        check_embed_field "embed-timestamps" ${{ toJSON(inputs.embed-timestamps) }}
        
        # Validate that all JSON arrays have the same length
        if [[ ${#array_lengths[@]} -gt 1 ]]; then
          # Convert associative array to indexed arrays for comparison
          lengths_found=()
          fields_found=()
          for field in "${!array_lengths[@]}"; do
            lengths_found+=("${array_lengths[$field]}")
            fields_found+=("$field")
          done
          
          # Compare all lengths to the first one
          first_length="${lengths_found[0]}"
          first_field="${fields_found[0]}"
          
          for i in "${!lengths_found[@]}"; do
            if [[ "${lengths_found[$i]}" != "$first_length" ]]; then
              ERRORS+=("Embed field array length mismatch: $first_field has $first_length elements, but ${fields_found[$i]} has ${lengths_found[$i]} elements. All JSON array inputs must have the same length.")
              break
            fi
          done
        fi
        
        # Validate embed count limit (max 10 embeds per Discord message)
        if [[ $embed_count -gt 10 ]]; then
          ERRORS+=("Discord allows a maximum of 10 embeds per message, but $embed_count embeds were specified")
        fi
        
        # If no embeds, validate that at least one of content, attachment-files, or attachment-urls is provided
        if [[ $embed_count -eq 0 ]]; then
          if [[ -z "${{ inputs.content }}" ]] && [[ -z "${{ inputs.attachment-files }}" ]] && [[ -z "${{ inputs.attachment-urls }}" ]]; then
            ERRORS+=("At least one of content, attachment-files, attachment-urls, or embed fields must be provided")
          fi
        fi
        
        # Validate embed-colors format (hex values)
        if [[ -n '${{ inputs.embed-colors }}' ]]; then
          colors='${{ inputs.embed-colors }}'
          if [[ "$colors" =~ ^\[.*\]$ ]]; then
            # JSON array - use process substitution to avoid subshell
            jq_output=$(echo "$colors" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r color; do
                [[ -z "$color" ]] && continue
                if [[ ! "$color" =~ ^[0-9A-Fa-f]{6}$ ]] && [[ ! "$color" =~ ^#[0-9A-Fa-f]{6}$ ]] && [[ ! "$color" =~ ^0x[0-9A-Fa-f]{6}$ ]]; then
                  ERRORS+=("embed-colors contains invalid hex color: $color (expected format: FF0000, #FF0000, or 0xFF0000)")
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ ! "$colors" =~ ^[0-9A-Fa-f]{6}$ ]] && [[ ! "$colors" =~ ^#[0-9A-Fa-f]{6}$ ]] && [[ ! "$colors" =~ ^0x[0-9A-Fa-f]{6}$ ]]; then
              ERRORS+=("embed-colors contains invalid hex color: $colors (expected format: FF0000, #FF0000, or 0xFF0000)")
            fi
          fi
        fi
        
        # Validate URL fields
        validate_url_field() {
          local field_name="$1"
          local field_value="$2"
          
          [[ -z "$field_value" ]] && return
          
          if [[ "$field_value" =~ ^\[.*\]$ ]]; then
            # JSON array - use heredoc to avoid subshell issues
            jq_output=$(echo "$field_value" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r url; do
                [[ -z "$url" ]] && continue
                if [[ ! "$url" =~ ^https?:// ]]; then
                  ERRORS+=("$field_name contains invalid URL: $url (must start with http:// or https://)")
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ ! "$field_value" =~ ^https?:// ]]; then
              ERRORS+=("$field_name must be a valid URL starting with http:// or https://")
            fi
          fi
        }
        
        validate_url_field "embed-urls" "${{ inputs.embed-urls }}"
        validate_url_field "embed-image-urls" "${{ inputs.embed-image-urls }}"
        validate_url_field "embed-thumbnail-urls" "${{ inputs.embed-thumbnail-urls }}"
        validate_url_field "embed-author-urls" "${{ inputs.embed-author-urls }}"
        validate_url_field "embed-author-icons" "${{ inputs.embed-author-icons }}"
        validate_url_field "embed-footer-icons" "${{ inputs.embed-footer-icons }}"
        
        # Validate embed-timestamps format (ISO 8601 or "now")
        if [[ -n "${{ inputs.embed-timestamps }}" ]]; then
          timestamps="${{ inputs.embed-timestamps }}"
          if [[ "$timestamps" =~ ^\[.*\]$ ]]; then
            # JSON array - use heredoc to avoid subshell issues
            jq_output=$(echo "$timestamps" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r ts; do
                [[ -z "$ts" ]] && continue
                if [[ "$ts" != "now" ]]; then
                  # Try both GNU date and BSD date formats
                  if ! date -d "$ts" &>/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%S" "$ts" &>/dev/null 2>&1; then
                    ERRORS+=("embed-timestamps contains invalid timestamp: $ts (expected ISO 8601 format or 'now')")
                  fi
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ "$timestamps" != "now" ]]; then
              if ! date -d "$timestamps" &>/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%S" "$timestamps" &>/dev/null 2>&1; then
                ERRORS+=("embed-timestamps contains invalid timestamp: $timestamps (expected ISO 8601 format or 'now')")
              fi
            fi
          fi
        fi
        
        # Validate embed-fields JSON format if provided
        if [[ -n '${{ toJSON(inputs.embed-fields) }}' ]]; then
          fields='${{ toJSON(inputs.embed-fields) }}'
          if ! echo "$fields" | jq empty 2>/dev/null; then
            ERRORS+=("embed-fields must be valid JSON")
          else
            # Validate structure: should be array or array of arrays
            if [[ "$fields" =~ ^\[.*\]$ ]]; then
              # Check if it's an array of arrays or array of objects - use heredoc
              jq_output=$(echo "$fields" | jq -r '.[]' 2>/dev/null || echo "")
              if [[ -n "$jq_output" ]]; then
                while IFS= read -r field; do
                  if [[ "$field" =~ ^\{.*\}$ ]]; then
                    # Validate field has required "name" and "value" properties
                    name=$(echo "$field" | jq -r '.name' 2>/dev/null || echo "null")
                    value=$(echo "$field" | jq -r '.value' 2>/dev/null || echo "null")
                    if [[ "$name" == "null" ]] || [[ "$value" == "null" ]]; then
                      ERRORS+=("embed-fields objects must contain 'name' and 'value' properties")
                    fi
                  fi
                done <<< "$jq_output"
              fi
            fi
          fi
        fi
        
        # Report all errors
        if [[ ${#ERRORS[@]} -gt 0 ]]; then
          echo -e "${RED}Input validation failed with ${#ERRORS[@]} error(s):${NC}"
          for error in "${ERRORS[@]}"; do
            echo -e "${RED}  ✗ $error${NC}"
            echo "::error::$error"
          done
          exit 1
        fi
        
        echo -e "${YELLOW}✓ All inputs validated successfully${NC}"
    
    - name: Build Discord Payload
      id: build_payload
      shell: bash
      run: |
        # Use jq to build the JSON payload based on inputs
        
        # Initialize base payload
        PAYLOAD='{}'
        
        # Add basic fields if provided
        if [[ -n "${{ inputs.username }}" ]]; then
          PAYLOAD=$(echo "$PAYLOAD" | jq --arg username "${{ inputs.username }}" '. + {username: $username}')
        fi
        
        if [[ -n "${{ inputs.avatar_url }}" ]]; then
          PAYLOAD=$(echo "$PAYLOAD" | jq --arg avatar_url "${{ inputs.avatar_url }}" '. + {avatar_url: $avatar_url}')
        fi
        
        if [[ -n "${{ inputs.content }}" ]]; then
          PAYLOAD=$(echo "$PAYLOAD" | jq --arg content "${{ inputs.content }}" '. + {content: $content}')
        fi
        
        # Helper function to get value from single or array
        get_value_at_index() {
          local input="$1"
          local index="$2"
          local field_name="$3"  # Optional: field name for special handling
          
          if [[ -z "$input" ]]; then
            echo "null"
            return
          fi
          
          # Check if it's a JSON array
          if [[ "$input" =~ ^\[.*\]$ ]]; then
            # Special handling for embed-fields
            if [[ "$field_name" == "embed-fields" ]]; then
              # Check if first element is an array or object
              local first_elem=$(echo "$input" | jq '.[0] | type' 2>/dev/null)
              if [[ "$first_elem" == '"array"' ]]; then
                # Array of arrays - extract the array at index
                local extracted=$(echo "$input" | jq ".[$index] // null" 2>/dev/null)
                echo "$extracted"
              else
                # Array of objects - return the whole array as single value
                echo "$input" | jq '.'
              fi
            else
              # For other fields, extract the value at the index
              local extracted=$(echo "$input" | jq ".[$index] // null" 2>/dev/null)
              if [[ "$extracted" == "null" ]]; then
                echo "null"
              else
                echo "$extracted"
              fi
            fi
          else
            # Single value - check if it's already valid JSON (object or array)
            if echo "$input" | jq empty 2>/dev/null; then
              # It's valid JSON (like an array or object), return it through jq to ensure proper formatting
              echo "$input" | jq '.'
            else
              # It's a plain string, quote it
              echo "$input" | jq -R '.'
            fi
          fi
        }
        
        # Helper function to convert hex color to decimal
        hex_to_decimal() {
          local color="$1"
          
          if [[ -z "$color" ]] || [[ "$color" == "null" ]]; then
            echo "null"
            return
          fi
          
          # Remove # or 0x prefix if present
          color="${color#\#}"
          color="${color#0x}"
          color="${color#0X}"
          
          # Convert hex to decimal
          echo $((16#$color))
        }
        
        # Helper function to convert timestamp
        convert_timestamp() {
          local ts="$1"
          
          if [[ -z "$ts" ]] || [[ "$ts" == "null" ]]; then
            echo "null"
            return
          fi
          
          if [[ "$ts" == "now" ]]; then
            # Generate current timestamp in ISO 8601 format
            date -u +"%Y-%m-%dT%H:%M:%SZ" | jq -R '.'
          else
            echo "$ts" | jq -R '.'
          fi
        }
        
        # Determine number of embeds
        EMBED_COUNT=0
        
        # Parse embed-fields through jq to handle JSON properly
        FIELDS_FOR_COUNT=$(echo '${{ toJSON(inputs.embed-fields) }}' | jq -r 'if . == "" then "" else . end')
        
        # Check each embed field to determine count
        for field_value in \
          "${{ inputs.embed-authors }}" \
          "${{ inputs.embed-titles }}" \
          "${{ inputs.embed-descriptions }}" \
          "${{ inputs.embed-colors }}" \
          "${{ inputs.embed-urls }}" \
          "${{ inputs.embed-image-urls }}" \
          "${{ inputs.embed-thumbnail-urls }}" \
          "$FIELDS_FOR_COUNT" \
          "${{ inputs.embed-footers }}" \
          "${{ inputs.embed-timestamps }}"; do
          
          if [[ -n "$field_value" ]]; then
            if [[ "$field_value" =~ ^\[.*\]$ ]]; then
              length=$(echo "$field_value" | jq '. | length' 2>/dev/null || echo "0")
              [[ $length -gt $EMBED_COUNT ]] && EMBED_COUNT=$length
            else
              [[ $EMBED_COUNT -lt 1 ]] && EMBED_COUNT=1
            fi
          fi
        done
        
        # Build embeds array if needed
        if [[ $EMBED_COUNT -gt 0 ]]; then
          EMBEDS='[]'
          
          for ((i=0; i<EMBED_COUNT; i++)); do
            EMBED='{}'
            
            # Get values for this embed index
            # Parse inputs through jq to handle JSON arrays properly from GitHub Actions
            AUTHOR_RAW=$(echo '${{ toJSON(inputs.embed-authors) }}' | jq -r 'if . == "" then "" else . end')
            AUTHOR=$(get_value_at_index "$AUTHOR_RAW" $i)
            AUTHOR_URL_RAW=$(echo '${{ toJSON(inputs.embed-author-urls) }}' | jq -r 'if . == "" then "" else . end')
            AUTHOR_URL=$(get_value_at_index "$AUTHOR_URL_RAW" $i)
            AUTHOR_ICON_RAW=$(echo '${{ toJSON(inputs.embed-author-icons) }}' | jq -r 'if . == "" then "" else . end')
            AUTHOR_ICON=$(get_value_at_index "$AUTHOR_ICON_RAW" $i)
            TITLE_RAW=$(echo '${{ toJSON(inputs.embed-titles) }}' | jq -r 'if . == "" then "" else . end')
            TITLE=$(get_value_at_index "$TITLE_RAW" $i)
            DESCRIPTION_RAW=$(echo '${{ toJSON(inputs.embed-descriptions) }}' | jq -r 'if . == "" then "" else . end')
            DESCRIPTION=$(get_value_at_index "$DESCRIPTION_RAW" $i)
            URL_RAW=$(echo '${{ toJSON(inputs.embed-urls) }}' | jq -r 'if . == "" then "" else . end')
            URL=$(get_value_at_index "$URL_RAW" $i)
            COLOR_HEX_RAW=$(echo '${{ toJSON(inputs.embed-colors) }}' | jq -r 'if . == "" then "" else . end')
            COLOR_HEX=$(get_value_at_index "$COLOR_HEX_RAW" $i)
            IMAGE_URL_RAW=$(echo '${{ toJSON(inputs.embed-image-urls) }}' | jq -r 'if . == "" then "" else . end')
            IMAGE_URL=$(get_value_at_index "$IMAGE_URL_RAW" $i)
            THUMBNAIL_URL_RAW=$(echo '${{ toJSON(inputs.embed-thumbnail-urls) }}' | jq -r 'if . == "" then "" else . end')
            THUMBNAIL_URL=$(get_value_at_index "$THUMBNAIL_URL_RAW" $i)
            # Parse embed-fields through jq to handle JSON properly from GitHub Actions
            FIELDS_RAW=$(echo '${{ toJSON(inputs.embed-fields) }}' | jq -r 'if . == "" then "" else . end')
            FIELDS=$(get_value_at_index "$FIELDS_RAW" $i "embed-fields")
            FOOTER_RAW=$(echo '${{ toJSON(inputs.embed-footers) }}' | jq -r 'if . == "" then "" else . end')
            FOOTER=$(get_value_at_index "$FOOTER_RAW" $i)
            FOOTER_ICON_RAW=$(echo '${{ toJSON(inputs.embed-footer-icons) }}' | jq -r 'if . == "" then "" else . end')
            FOOTER_ICON=$(get_value_at_index "$FOOTER_ICON_RAW" $i)
            TIMESTAMP_RAW=$(echo '${{ toJSON(inputs.embed-timestamps) }}' | jq -r 'if . == "" then "" else . end')
            TIMESTAMP=$(get_value_at_index "$TIMESTAMP_RAW" $i)
            
            # Build author object if any author field is present
            if [[ "$AUTHOR" != "null" ]] || [[ "$AUTHOR_URL" != "null" ]] || [[ "$AUTHOR_ICON" != "null" ]]; then
              AUTHOR_OBJ='{}'
              [[ "$AUTHOR" != "null" ]] && AUTHOR_OBJ=$(echo "$AUTHOR_OBJ" | jq --argjson name "$AUTHOR" '. + {name: $name}')
              [[ "$AUTHOR_URL" != "null" ]] && AUTHOR_OBJ=$(echo "$AUTHOR_OBJ" | jq --argjson url "$AUTHOR_URL" '. + {url: $url}')
              [[ "$AUTHOR_ICON" != "null" ]] && AUTHOR_OBJ=$(echo "$AUTHOR_OBJ" | jq --argjson icon_url "$AUTHOR_ICON" '. + {icon_url: $icon_url}')
              EMBED=$(echo "$EMBED" | jq --argjson author "$AUTHOR_OBJ" '. + {author: $author}')
            fi
            
            # Add basic embed fields
            [[ "$TITLE" != "null" ]] && EMBED=$(echo "$EMBED" | jq --argjson title "$TITLE" '. + {title: $title}')
            [[ "$DESCRIPTION" != "null" ]] && EMBED=$(echo "$EMBED" | jq --argjson description "$DESCRIPTION" '. + {description: $description}')
            [[ "$URL" != "null" ]] && EMBED=$(echo "$EMBED" | jq --argjson url "$URL" '. + {url: $url}')
            
            # Add color (convert hex to decimal)
            if [[ "$COLOR_HEX" != "null" ]]; then
              COLOR_DEC=$(hex_to_decimal "$(echo "$COLOR_HEX" | jq -r '.')")
              [[ "$COLOR_DEC" != "null" ]] && EMBED=$(echo "$EMBED" | jq --argjson color "$COLOR_DEC" '. + {color: $color}')
            fi
            
            # Add fields array if present
            if [[ "$FIELDS" != "null" ]]; then
              # Fields should already be a JSON array
              EMBED=$(echo "$EMBED" | jq --argjson fields "$FIELDS" '. + {fields: $fields}')
            fi
            
            # Add thumbnail if present
            if [[ "$THUMBNAIL_URL" != "null" ]]; then
              THUMBNAIL_OBJ=$(jq -n --argjson url "$THUMBNAIL_URL" '{url: $url}')
              EMBED=$(echo "$EMBED" | jq --argjson thumbnail "$THUMBNAIL_OBJ" '. + {thumbnail: $thumbnail}')
            fi
            
            # Add image if present
            if [[ "$IMAGE_URL" != "null" ]]; then
              IMAGE_OBJ=$(jq -n --argjson url "$IMAGE_URL" '{url: $url}')
              EMBED=$(echo "$EMBED" | jq --argjson image "$IMAGE_OBJ" '. + {image: $image}')
            fi
            
            # Build footer object if any footer field is present
            if [[ "$FOOTER" != "null" ]] || [[ "$FOOTER_ICON" != "null" ]]; then
              FOOTER_OBJ='{}'
              [[ "$FOOTER" != "null" ]] && FOOTER_OBJ=$(echo "$FOOTER_OBJ" | jq --argjson text "$FOOTER" '. + {text: $text}')
              [[ "$FOOTER_ICON" != "null" ]] && FOOTER_OBJ=$(echo "$FOOTER_OBJ" | jq --argjson icon_url "$FOOTER_ICON" '. + {icon_url: $icon_url}')
              EMBED=$(echo "$EMBED" | jq --argjson footer "$FOOTER_OBJ" '. + {footer: $footer}')
            fi
            
            # Add timestamp if present
            if [[ "$TIMESTAMP" != "null" ]]; then
              TS_VALUE=$(convert_timestamp "$(echo "$TIMESTAMP" | jq -r '.')")
              [[ "$TS_VALUE" != "null" ]] && EMBED=$(echo "$EMBED" | jq --argjson timestamp "$TS_VALUE" '. + {timestamp: $timestamp}')
            fi
            
            # Add embed to embeds array
            EMBEDS=$(echo "$EMBEDS" | jq --argjson embed "$EMBED" '. + [$embed]')
          done
          
          # Add embeds to payload
          PAYLOAD=$(echo "$PAYLOAD" | jq --argjson embeds "$EMBEDS" '. + {embeds: $embeds}')
        fi
        
        # Output payload to file for next step
        echo "$PAYLOAD" > ${{ runner.temp }}/discord_payload.json
        echo "payload_file=${{ runner.temp }}/discord_payload.json" >> $GITHUB_OUTPUT
        
        # Also output the payload as a string for the output
        echo "payload<<EOF" >> $GITHUB_OUTPUT
        echo "$PAYLOAD" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "Discord payload built successfully"
        echo "$PAYLOAD" | jq '.'
        
    - name: Send Discord Message
      id: send_discord_message
      shell: bash
      run: |
        # Read payload from file
        PAYLOAD_FILE="${{ steps.build_payload.outputs.payload_file }}"
        PAYLOAD_CONTENT=$(cat "$PAYLOAD_FILE")

        # Send request and capture both status code and response
        HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ inputs.webhook_url }}" \
                             -H "Content-Type: application/json" \
                             -d "$PAYLOAD_CONTENT")
        
        # Extract status code (last line) and body (everything else)
        HTTP_CODE=$(echo "$HTTP_RESPONSE" | tail -n1)
        echo "status_code=$HTTP_CODE" >> $GITHUB_OUTPUT
        RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
        
        # Check if request was successful (200-299 status codes)
        if [[ "$HTTP_CODE" =~ ^2[0-9][0-9]$ ]]; then
          echo "Discord message sent successfully (HTTP $HTTP_CODE)"
          
          # Try to extract message ID if response body exists
          if [[ -n "$RESPONSE_BODY" ]] && echo "$RESPONSE_BODY" | jq -e 'has("id")' >/dev/null 2>&1; then
            MESSAGE_ID=$(echo "$RESPONSE_BODY" | jq -r '.id')
            echo "message_id=$MESSAGE_ID" >> $GITHUB_OUTPUT
            echo "Message ID: $MESSAGE_ID"
          else
            echo "message_id=" >> $GITHUB_OUTPUT
            echo "Note: No message ID returned (webhook may not have wait=true parameter)"
          fi
        else
          echo "Failed to send Discord message (HTTP $HTTP_CODE)"
          if [[ -n "$RESPONSE_BODY" ]]; then
            echo "Error response:"
            echo "$RESPONSE_BODY" | jq '.' 2>/dev/null || echo "$RESPONSE_BODY"
          fi
          echo "::error::Failed to send Discord message (HTTP $HTTP_CODE)"
          exit 1
        fi

