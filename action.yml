---
name: Discord Notifier
author: Chase Roohms
description: Send messages to Discord via webhook
branding:
  icon: 'bell'
  color: 'purple'

inputs:
  webhook_url:
    description: 'The Discord webhook URL to send the message to'
    required: true
  #### Parts of the normal message, that are not in an embed ####
  # All of these options are optional, but at least one of content, attachment-files,
  # or attachment-urls must be provided if you do not provide any embeds below.
  content:
    description: 'The message to send to Discord, used in the "content" field if embeds are enabled.'
    required: false
    default: ''
  username:
    description: 'The username to display as the message sender'
    required: false
    default: ''
  avatar_url:
    description: 'The URL of the avatar image to use for the message sender'
    required: false
    default: ''
  attachment-files:
    description: 'A newline-separated list of files to upload and attach to the message (mutually exclusive with attachment-urls)'
    required: false
    default: ''
  attachment-urls:
    description: 'A newline-separated list of URLs to attach to the message (mutually exclusive with attachment-files)'
    required: false
    default: ''
  
  #### Embed options ####
  # You can attach up to 10 embeds per message, each with their own options
  # meaning that for each of these you can specify a single value, or a json
  # array of values. If you specify a single value, it will be used for all embeds.
  # If you specify a json array, it should contain one entry per embed.
  # For example, to send 3 embeds with different titles, you would set
  # embed-titles to '["Title 1", "Title 2", "Title 3"]'
  # If you only wanted to set the title for the first embed, and leave the rest blank,
  # you would set embed-titles to '["Title 1", "", ""]'
  # If you wanted to send 2 embeds, both with the same title, you would set
  # embed-titles to 'Common Title'

  # Author fields
  embed-authors:
    description: 'The authors of the embeds to include in the message'
    required: false
    default: ''
  embed-author-urls:
    description: 'The author URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-author-icons:
    description: 'The author icon URLs of the embeds to include in the message'
    required: false
    default: ''
  
  # Main embed fields
  embed-titles:
    description: 'The titles of the embeds to include in the message'
    required: false
    default: ''
  embed-descriptions:
    description: 'The descriptions of the embeds to include in the message'
    required: false
    default: ''
  embed-urls:
    description: 'The URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-colors:
    description: 'The colors of the embeds to include in the message, as hex values (e.g., FF0000 for red)'
    required: false
    default: ''
  embed-image-urls:
    description: 'The main image URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-thumbnail-urls:
    description: 'The thumbnail image URLs of the embeds to include in the message'
    required: false
    default: ''
  
  # Fields
  embed-fields:
    # Expecting JSON arrays like: [{"name": "Field 1", "value": "Value 1", "inline": true}, {"name": "Field 2", "value": "Value 2", "inline": false}]
    description: 'The fields of the embeds to include in the message, as JSON arrays'
    required: false
    default: ''

  # Footer fields
  embed-footers:
    description: 'The footers of the embeds to include in the message'
    required: false
    default: ''
  embed-footer-icons:
    description: 'The footer icon URLs of the embeds to include in the message'
    required: false
    default: ''
  embed-timestamps:
    description: 'The timestamps of the embeds to include in the message, as ISO 8601 strings. Or "now" for the current time.'
    required: false
    default: ''

outputs: 
  message_id:
    description: 'The ID of the sent Discord message'
    value: ${{ steps.send_discord_message.outputs.message_id }}
  payload:
    description: 'The full payload sent to Discord'
    value: ${{ steps.send_discord_message.outputs.payload }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        # Ensure script doesn't exit on command failures
        set +e
        
        # Color codes for output
        RED='\033[0;31m'
        YELLOW='\033[1;33m'
        NC='\033[0m' # No Color
        
        # Track validation errors
        ERRORS=()
        
        # Validate webhook_url (required)
        if [[ -z "${{ inputs.webhook_url }}" ]]; then
          ERRORS+=("webhook_url is required")
        elif [[ ! "${{ inputs.webhook_url }}" =~ ^https://discord(app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+$ ]]; then
          ERRORS+=("webhook_url must be a valid Discord webhook URL (format: https://discord.com/api/webhooks/{id}/{token})")
        fi
        
        # Validate avatar_url if provided
        if [[ -n "${{ inputs.avatar_url }}" ]] && [[ ! "${{ inputs.avatar_url }}" =~ ^https?:// ]]; then
          ERRORS+=("avatar_url must be a valid URL starting with http:// or https://")
        fi
        
        # Validate attachment-files and attachment-urls are mutually exclusive
        if [[ -n "${{ inputs.attachment-files }}" ]] && [[ -n "${{ inputs.attachment-urls }}" ]]; then
          ERRORS+=("attachment-files and attachment-urls are mutually exclusive - provide only one")
        fi
        
        # Validate attachment-urls format if provided
        if [[ -n "${{ inputs.attachment-urls }}" ]]; then
          while IFS= read -r url; do
            [[ -z "$url" ]] && continue
            if [[ ! "$url" =~ ^https?:// ]]; then
              ERRORS+=("attachment-urls contains invalid URL: $url (must start with http:// or https://)")
            fi
          done <<< "${{ inputs.attachment-urls }}"
        fi
        
        # Validate attachment-files exist if provided
        if [[ -n "${{ inputs.attachment-files }}" ]]; then
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if [[ ! -f "$file" ]]; then
              ERRORS+=("attachment-files references non-existent file: $file")
            fi
          done <<< "${{ inputs.attachment-files }}"
        fi
        
        # Validate embed inputs
        embed_count=0
        declare -A array_lengths
        
        # Check each embed field and track array lengths
        check_embed_field() {
          local field_name="$1"
          local field_value="$2"
          
          echo "Debug: Checking field '$field_name'"
          echo "Debug: Full value: '$field_value'"
          echo "Debug: Value length: ${#field_value}"
          
          if [[ -n "$field_value" ]]; then
            # Check if it matches JSON array pattern (starts with [ and ends with ])
            if [[ "$field_value" =~ ^\[.*\]$ ]]; then
              echo "Debug: Field '$field_name' looks like a JSON array"
              
              # Try to parse with jq and capture any errors
              local jq_error
              jq_error=$(echo "$field_value" | jq empty 2>&1)
              local jq_status=$?
              
              if [[ $jq_status -ne 0 ]]; then
                echo "Debug: jq parse error for '$field_name': $jq_error"
                echo "Debug: This is NOT valid JSON. Valid JSON arrays require quoted strings, e.g., [\"value1\", \"value2\"]"
                # Treat as invalid - don't count it
                return
              fi
              
              # It's a valid JSON array - get its length
              local length=$(echo "$field_value" | jq '. | length' 2>/dev/null)
              echo "Debug: jq returned length: '$length' for field '$field_name'"
              if [[ -n "$length" ]] && [[ "$length" =~ ^[0-9]+$ ]]; then
                array_lengths["$field_name"]=$length
                echo "Debug: Set array_lengths['$field_name']=$length"
                [[ $length -gt $embed_count ]] && embed_count=$length
              else
                echo "Debug: Length validation failed for '$field_name' (length='$length')"
              fi
            else
              echo "Debug: Field '$field_name' is a single value (doesn't match ^\\[.*\\]$ pattern)"
              # It's a single value - this is fine, it will be used for all embeds
              [[ $embed_count -lt 1 ]] && embed_count=1
            fi
          else
            echo "Debug: Field '$field_name' is empty"
          fi
        }
        
        # Check all embed fields
        check_embed_field "embed-authors" ${{ toJSON(inputs.embed-authors) }}
        check_embed_field "embed-author-urls" ${{ toJSON(inputs.embed-author-urls) }}
        check_embed_field "embed-author-icons" ${{ toJSON(inputs.embed-author-icons) }}
        check_embed_field "embed-titles" ${{ toJSON(inputs.embed-titles) }}
        check_embed_field "embed-descriptions" ${{ toJSON(inputs.embed-descriptions) }}
        check_embed_field "embed-urls" ${{ toJSON(inputs.embed-urls) }}
        check_embed_field "embed-colors" ${{ toJSON(inputs.embed-colors) }}
        check_embed_field "embed-image-urls" ${{ toJSON(inputs.embed-image-urls) }}
        check_embed_field "embed-thumbnail-urls" ${{ toJSON(inputs.embed-thumbnail-urls) }}
        check_embed_field "embed-fields" ${{ toJSON(inputs.embed-fields) }}
        check_embed_field "embed-footers" ${{ toJSON(inputs.embed-footers) }}
        check_embed_field "embed-footer-icons" ${{ toJSON(inputs.embed-footer-icons) }}
        check_embed_field "embed-timestamps" ${{ toJSON(inputs.embed-timestamps) }}
        
        # Debug: Print array lengths detected
        echo "Debug: After all checks, array_lengths has ${#array_lengths[@]} entries"
        echo "Debug: array_lengths keys: ${!array_lengths[@]}"
        if [[ ${#array_lengths[@]} -gt 0 ]]; then
          echo "Debug: Detected ${#array_lengths[@]} fields with JSON arrays:"
          for field in "${!array_lengths[@]}"; do
            echo "  - $field: ${array_lengths[$field]} elements"
          done
        else
          echo "Debug: No JSON array fields were detected"
        fi
        
        # Validate that all JSON arrays have the same length
        if [[ ${#array_lengths[@]} -gt 1 ]]; then
          # Convert associative array to indexed arrays for comparison
          lengths_found=()
          fields_found=()
          for field in "${!array_lengths[@]}"; do
            lengths_found+=("${array_lengths[$field]}")
            fields_found+=("$field")
          done
          
          # Compare all lengths to the first one
          first_length="${lengths_found[0]}"
          first_field="${fields_found[0]}"
          
          for i in "${!lengths_found[@]}"; do
            if [[ "${lengths_found[$i]}" != "$first_length" ]]; then
              ERRORS+=("Embed field array length mismatch: $first_field has $first_length elements, but ${fields_found[$i]} has ${lengths_found[$i]} elements. All JSON array inputs must have the same length.")
              break
            fi
          done
        fi
        
        # Validate embed count limit (max 10 embeds per Discord message)
        if [[ $embed_count -gt 10 ]]; then
          ERRORS+=("Discord allows a maximum of 10 embeds per message, but $embed_count embeds were specified")
        fi
        
        # If no embeds, validate that at least one of content, attachment-files, or attachment-urls is provided
        if [[ $embed_count -eq 0 ]]; then
          if [[ -z "${{ inputs.content }}" ]] && [[ -z "${{ inputs.attachment-files }}" ]] && [[ -z "${{ inputs.attachment-urls }}" ]]; then
            ERRORS+=("At least one of content, attachment-files, attachment-urls, or embed fields must be provided")
          fi
        fi
        
        # Validate embed-colors format (hex values)
        if [[ -n "${{ inputs.embed-colors }}" ]]; then
          colors="${{ inputs.embed-colors }}"
          if [[ "$colors" =~ ^\[.*\]$ ]]; then
            # JSON array - use process substitution to avoid subshell
            jq_output=$(echo "$colors" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r color; do
                [[ -z "$color" ]] && continue
                if [[ ! "$color" =~ ^[0-9A-Fa-f]{6}$ ]] && [[ ! "$color" =~ ^#[0-9A-Fa-f]{6}$ ]] && [[ ! "$color" =~ ^0x[0-9A-Fa-f]{6}$ ]]; then
                  ERRORS+=("embed-colors contains invalid hex color: $color (expected format: FF0000, #FF0000, or 0xFF0000)")
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ ! "$colors" =~ ^[0-9A-Fa-f]{6}$ ]] && [[ ! "$colors" =~ ^#[0-9A-Fa-f]{6}$ ]] && [[ ! "$colors" =~ ^0x[0-9A-Fa-f]{6}$ ]]; then
              ERRORS+=("embed-colors contains invalid hex color: $colors (expected format: FF0000, #FF0000, or 0xFF0000)")
            fi
          fi
        fi
        
        # Validate URL fields
        validate_url_field() {
          local field_name="$1"
          local field_value="$2"
          
          [[ -z "$field_value" ]] && return
          
          if [[ "$field_value" =~ ^\[.*\]$ ]]; then
            # JSON array - use heredoc to avoid subshell issues
            jq_output=$(echo "$field_value" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r url; do
                [[ -z "$url" ]] && continue
                if [[ ! "$url" =~ ^https?:// ]]; then
                  ERRORS+=("$field_name contains invalid URL: $url (must start with http:// or https://)")
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ ! "$field_value" =~ ^https?:// ]]; then
              ERRORS+=("$field_name must be a valid URL starting with http:// or https://")
            fi
          fi
        }
        
        validate_url_field "embed-urls" "${{ inputs.embed-urls }}"
        validate_url_field "embed-image-urls" "${{ inputs.embed-image-urls }}"
        validate_url_field "embed-thumbnail-urls" "${{ inputs.embed-thumbnail-urls }}"
        validate_url_field "embed-author-urls" "${{ inputs.embed-author-urls }}"
        validate_url_field "embed-author-icons" "${{ inputs.embed-author-icons }}"
        validate_url_field "embed-footer-icons" "${{ inputs.embed-footer-icons }}"
        
        # Validate embed-timestamps format (ISO 8601 or "now")
        if [[ -n "${{ inputs.embed-timestamps }}" ]]; then
          timestamps="${{ inputs.embed-timestamps }}"
          if [[ "$timestamps" =~ ^\[.*\]$ ]]; then
            # JSON array - use heredoc to avoid subshell issues
            jq_output=$(echo "$timestamps" | jq -r '.[]' 2>/dev/null || echo "")
            if [[ -n "$jq_output" ]]; then
              while IFS= read -r ts; do
                [[ -z "$ts" ]] && continue
                if [[ "$ts" != "now" ]]; then
                  # Try both GNU date and BSD date formats
                  if ! date -d "$ts" &>/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%S" "$ts" &>/dev/null 2>&1; then
                    ERRORS+=("embed-timestamps contains invalid timestamp: $ts (expected ISO 8601 format or 'now')")
                  fi
                fi
              done <<< "$jq_output"
            fi
          else
            # Single value
            if [[ "$timestamps" != "now" ]]; then
              if ! date -d "$timestamps" &>/dev/null 2>&1 && ! date -j -f "%Y-%m-%dT%H:%M:%S" "$timestamps" &>/dev/null 2>&1; then
                ERRORS+=("embed-timestamps contains invalid timestamp: $timestamps (expected ISO 8601 format or 'now')")
              fi
            fi
          fi
        fi
        
        # Validate embed-fields JSON format if provided
        if [[ -n "${{ inputs.embed-fields }}" ]]; then
          fields="${{ inputs.embed-fields }}"
          if ! echo "$fields" | jq empty 2>/dev/null; then
            ERRORS+=("embed-fields must be valid JSON")
          else
            # Validate structure: should be array or array of arrays
            if [[ "$fields" =~ ^\[.*\]$ ]]; then
              # Check if it's an array of arrays or array of objects - use heredoc
              jq_output=$(echo "$fields" | jq -r '.[]' 2>/dev/null || echo "")
              if [[ -n "$jq_output" ]]; then
                while IFS= read -r field; do
                  if [[ "$field" =~ ^\{.*\}$ ]]; then
                    # Validate field has required "name" and "value" properties
                    name=$(echo "$field" | jq -r '.name' 2>/dev/null || echo "null")
                    value=$(echo "$field" | jq -r '.value' 2>/dev/null || echo "null")
                    if [[ "$name" == "null" ]] || [[ "$value" == "null" ]]; then
                      ERRORS+=("embed-fields objects must contain 'name' and 'value' properties")
                    fi
                  fi
                done <<< "$jq_output"
              fi
            fi
          fi
        fi
        
        # Report all errors
        echo "Debug: Total errors collected: ${#ERRORS[@]}"
        if [[ ${#ERRORS[@]} -gt 0 ]]; then
          echo -e "${RED}Input validation failed with ${#ERRORS[@]} error(s):${NC}"
          for error in "${ERRORS[@]}"; do
            echo -e "${RED}  ✗ $error${NC}"
            echo "::error::$error"
          done
          exit 1
        fi
        
        echo -e "${YELLOW}✓ All inputs validated successfully${NC}"